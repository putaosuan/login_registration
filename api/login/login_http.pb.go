// Code generated by protoc-gen-go-http. DO NOT EDIT.
// versions:
// protoc-gen-go-http v1.0.0

package login

import (
	context "context"
	http "github.com/go-kirito/pkg/transport/http"
	binding "github.com/go-kirito/pkg/transport/http/binding"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
var _ = new(context.Context)
var _ = binding.EncodeURL

const _ = http.SupportPackageIsVersion1

type LoginHTTPServer interface {
	CreateLogin(context.Context, *CreateLoginRequest) (*CreateLoginReply, error)
	DeleteLogin(context.Context, *DeleteLoginRequest) (*DeleteLoginReply, error)
	GetLogin(context.Context, *GetLoginRequest) (*GetLoginReply, error)
	ListLogin(context.Context, *ListLoginRequest) (*ListLoginReply, error)
	UpdateLogin(context.Context, *UpdateLoginRequest) (*UpdateLoginReply, error)
}

func RegisterLoginHTTPServer(s *http.Server, srv LoginHTTPServer) {
	r := s.Route("/")
	r.POST("helloworld", _Login_CreateLogin0_HTTP_Handler(srv))
	r.PUT("helloworld/{name}", _Login_UpdateLogin0_HTTP_Handler(srv))
	r.DELETE("helloworld/{name}", _Login_DeleteLogin0_HTTP_Handler(srv))
	r.GET("helloworld/{name}", _Login_GetLogin0_HTTP_Handler(srv))
	r.GET("helloworld", _Login_ListLogin0_HTTP_Handler(srv))
}

func _Login_CreateLogin0_HTTP_Handler(srv LoginHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in CreateLoginRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/api.login.Login/CreateLogin")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.CreateLogin(ctx, req.(*CreateLoginRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*CreateLoginReply)
		return ctx.Result(200, reply)
	}
}

func _Login_UpdateLogin0_HTTP_Handler(srv LoginHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in UpdateLoginRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/api.login.Login/UpdateLogin")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.UpdateLogin(ctx, req.(*UpdateLoginRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*UpdateLoginReply)
		return ctx.Result(200, reply)
	}
}

func _Login_DeleteLogin0_HTTP_Handler(srv LoginHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in DeleteLoginRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/api.login.Login/DeleteLogin")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.DeleteLogin(ctx, req.(*DeleteLoginRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*DeleteLoginReply)
		return ctx.Result(200, reply)
	}
}

func _Login_GetLogin0_HTTP_Handler(srv LoginHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetLoginRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/api.login.Login/GetLogin")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetLogin(ctx, req.(*GetLoginRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GetLoginReply)
		return ctx.Result(200, reply)
	}
}

func _Login_ListLogin0_HTTP_Handler(srv LoginHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ListLoginRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/api.login.Login/ListLogin")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ListLogin(ctx, req.(*ListLoginRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ListLoginReply)
		return ctx.Result(200, reply)
	}
}

type LoginHTTPClient interface {
	CreateLogin(ctx context.Context, req *CreateLoginRequest, opts ...http.CallOption) (rsp *CreateLoginReply, err error)
	DeleteLogin(ctx context.Context, req *DeleteLoginRequest, opts ...http.CallOption) (rsp *DeleteLoginReply, err error)
	GetLogin(ctx context.Context, req *GetLoginRequest, opts ...http.CallOption) (rsp *GetLoginReply, err error)
	ListLogin(ctx context.Context, req *ListLoginRequest, opts ...http.CallOption) (rsp *ListLoginReply, err error)
	UpdateLogin(ctx context.Context, req *UpdateLoginRequest, opts ...http.CallOption) (rsp *UpdateLoginReply, err error)
}

type LoginHTTPClientImpl struct {
	cc *http.Client
}

func NewLoginHTTPClient(client *http.Client) LoginHTTPClient {
	return &LoginHTTPClientImpl{client}
}

func (c *LoginHTTPClientImpl) CreateLogin(ctx context.Context, in *CreateLoginRequest, opts ...http.CallOption) (*CreateLoginReply, error) {
	var out CreateLoginReply
	pattern := "helloworld"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation("/api.login.Login/CreateLogin"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *LoginHTTPClientImpl) DeleteLogin(ctx context.Context, in *DeleteLoginRequest, opts ...http.CallOption) (*DeleteLoginReply, error) {
	var out DeleteLoginReply
	pattern := "helloworld/{name}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation("/api.login.Login/DeleteLogin"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "DELETE", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *LoginHTTPClientImpl) GetLogin(ctx context.Context, in *GetLoginRequest, opts ...http.CallOption) (*GetLoginReply, error) {
	var out GetLoginReply
	pattern := "helloworld/{name}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation("/api.login.Login/GetLogin"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *LoginHTTPClientImpl) ListLogin(ctx context.Context, in *ListLoginRequest, opts ...http.CallOption) (*ListLoginReply, error) {
	var out ListLoginReply
	pattern := "helloworld"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation("/api.login.Login/ListLogin"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *LoginHTTPClientImpl) UpdateLogin(ctx context.Context, in *UpdateLoginRequest, opts ...http.CallOption) (*UpdateLoginReply, error) {
	var out UpdateLoginReply
	pattern := "helloworld/{name}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation("/api.login.Login/UpdateLogin"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "PUT", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}
